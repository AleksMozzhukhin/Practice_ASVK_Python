# командная строка и объекты
# кортеж - индексируемая, но неизменяемая структура данных
a = (1, 2, 3, "asdfew")
b = (1, 2, 3, "asdfew")
print(a == b)
print(id(a), id(b))  # они одинаковы, но всё же это разные объекты
print(a is b)  # поэтому такое выражение ложно
print(a in b)

# в питоне всё объекты, к примеру
t = type("123")
print(t)

# типизация в питоне динамеческая, но строгая

# Функции в Питон
# Функции - тоже объекты в питоне, поэтмоу их можно передавать как аргументы другим функциям

# def f(a, b):
#     return 5 * a + b
#
#
# def func(a, b, c):
#     return 2 * c(a, b) - c(b, a)
#
#
# a = f
# print(a(2, 5, f))

# объекты и связывания
# есть объекты и его имена. к примеру:
a = b = c = [1, 234, "ergvwe", None]
# получим, что a==b True и a is b True
# значит, проссматривая пространство имён (dir()), мы найдём там имена a, b, c. Удаляя их (del(a)) мы удалим сам объект только после удаления всех его имён
# в питоне операция = — это операция СВЯЗЫВАНИЯ, а не присваивания
d = c  # это всё ещё тот же самый объект

# множественное связывание

q, w, e = 1, 2, 3  # слева стоит перечисляемая последовательность, а справа какой-то набор данных
q, *w, e = range(3, 7)
print(w)

# Словари
g = {"sd": 213, 1: "argwtb"}
print(g[1])

# операция(не оператор) связывания
# while chunk := fp.read(200): #работает как в С
#     print(chunk)

# refcount

a, b = 1192, 1192;
c = 1192
print(a is b is c)  # True

# Но

a, b = 1192, 1192
c = 1192
print(a is b is c)  # False (т.к. создавалось на на одном моменте интерпритации)

a = [1, 2, "QQ"];
b = [a, 4];
a[1] = b
c = a, b
print(a)
import sys

print(sys.getrefcount(a))
print(sys.getrefcount(c[0]))
del a, b
print(sys.getrefcount(c[0]))
#замечаем, что у нас "зависли" сслыки друг на друга, поэтому нужен сборщик мусора gc
import gc
gc.disable()
gc.set_debug(gc.DEBUG_LEAK)
gc.collect()
print(sys.getrefcount(c[0]))